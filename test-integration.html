<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MuralBot Integration Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .test-controls {
            padding: 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .test-stats {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .stat-box {
            flex: 1;
            padding: 15px;
            background: white;
            border-radius: 6px;
            text-align: center;
            border: 2px solid #e5e7eb;
        }

        .stat-box.passed {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .stat-box.failed {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9em;
        }

        .test-results {
            padding: 20px;
        }

        .test-category {
            margin-bottom: 30px;
        }

        .category-header {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .test-case {
            margin-bottom: 15px;
            padding: 15px;
            background: #f9fafb;
            border-radius: 6px;
            border-left: 4px solid #9ca3af;
        }

        .test-case.running {
            border-left-color: #3b82f6;
            background: #eff6ff;
        }

        .test-case.passed {
            border-left-color: #10b981;
            background: #f0fdf4;
        }

        .test-case.failed {
            border-left-color: #ef4444;
            background: #fef2f2;
        }

        .test-name {
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .test-status {
            font-size: 0.9em;
            color: #6b7280;
        }

        .test-status.passed {
            color: #10b981;
        }

        .test-status.failed {
            color: #ef4444;
        }

        .test-status.running {
            color: #3b82f6;
        }

        .test-details {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }

        .test-error {
            color: #dc2626;
            margin-top: 8px;
            padding: 8px;
            background: #fee;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85em;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .canvas-wrapper {
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 10px;
            background: white;
        }

        .canvas-label {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 8px;
            font-weight: 600;
        }

        canvas {
            max-width: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #1f2937;
            color: #10b981;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-error {
            color: #ef4444;
        }

        .log-warn {
            color: #f59e0b;
        }

        .log-info {
            color: #3b82f6;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß™ MuralBot Integration Tests</h1>
            <p>Comprehensive end-to-end testing suite for Phase 10</p>
        </header>

        <div class="test-controls">
            <button class="btn btn-primary" id="run-all-tests">‚ñ∂Ô∏è Run All Tests</button>
            <button class="btn btn-success" id="run-quick-tests">‚ö° Quick Test</button>
            <button class="btn btn-secondary" id="clear-results">üóëÔ∏è Clear Results</button>
            <input type="file" id="test-image-upload" accept="image/*" style="display: none;">
            <button class="btn btn-secondary" id="upload-test-image">üìÅ Upload Test Image</button>
        </div>

        <div class="test-stats">
            <div class="stat-box" id="stat-total">
                <div class="stat-value">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-box passed" id="stat-passed">
                <div class="stat-value">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-box failed" id="stat-failed">
                <div class="stat-value">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-box" id="stat-time">
                <div class="stat-value">0s</div>
                <div class="stat-label">Duration</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>

        <div class="test-results" id="test-results">
            <!-- Test results will be dynamically added here -->
        </div>

        <div class="log-container" id="log-container">
            <div class="log-entry">üöÄ Integration Test Suite Ready</div>
            <div class="log-entry">Click "Run All Tests" to begin comprehensive testing</div>
        </div>
    </div>

    <script type="module">
        import eventBus, { Events } from './js/core/eventBus.js';
        import state from './js/core/state.js';
        import imageLoader from './js/processing/imageLoader.js';
        import canvasManager from './js/processing/canvasManager.js';
        import imagePreprocessor from './js/processing/imagePreprocessor.js';
        import colorSeparator from './js/processing/colorSeparator.js';
        import kMeans from './js/algorithms/kMeans.js';
        import edgeDetection from './js/algorithms/edgeDetection.js';
        import gcodeGenerator from './js/gcode/gcodeGenerator.js';
        import { PreviewGenerator } from './js/simulation/previewGenerator.js';
        import { JobEstimator } from './js/estimation/jobEstimator.js';

        // Test suite state
        let testResults = [];
        let currentCategory = null;
        let startTime = null;
        let testImageData = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('Initializing test environment...');
            initializeEventListeners();
            createTestCategories();
            log('Test environment ready', 'info');
        });

        function initializeEventListeners() {
            document.getElementById('run-all-tests').addEventListener('click', runAllTests);
            document.getElementById('run-quick-tests').addEventListener('click', runQuickTests);
            document.getElementById('clear-results').addEventListener('click', clearResults);
            document.getElementById('upload-test-image').addEventListener('click', () => {
                document.getElementById('test-image-upload').click();
            });
            document.getElementById('test-image-upload').addEventListener('change', handleTestImageUpload);
        }

        async function handleTestImageUpload(e) {
            try {
                const file = e.target.files[0];
                if (!file) return;

                log(`Loading test image: ${file.name}`, 'info');
                
                const img = await loadImageFromFile(file);
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                testImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                log(`‚úÖ Test image loaded: ${img.width}x${img.height}`, 'info');
            } catch (error) {
                log(`‚ùå Error loading test image: ${error.message}`, 'error');
            }
        }

        function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        function createTestCategories() {
            const categories = [
                { id: 'core', name: 'üèóÔ∏è Core Infrastructure', tests: [] },
                { id: 'processing', name: 'üñºÔ∏è Image Processing', tests: [] },
                { id: 'algorithms', name: 'üßÆ Algorithms', tests: [] },
                { id: 'gcode', name: '‚öôÔ∏è G-Code Generation', tests: [] },
                { id: 'simulation', name: 'üé¨ Simulation & Preview', tests: [] },
                { id: 'estimation', name: 'üìä Job Estimation', tests: [] },
                { id: 'integration', name: 'üîó End-to-End Integration', tests: [] }
            ];

            const resultsContainer = document.getElementById('test-results');
            categories.forEach(cat => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'test-category';
                categoryDiv.id = `category-${cat.id}`;
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <span>${cat.name}</span>
                        <span class="category-status" id="status-${cat.id}"></span>
                    </div>
                    <div class="category-tests" id="tests-${cat.id}"></div>
                `;
                resultsContainer.appendChild(categoryDiv);
            });
        }

        async function runAllTests() {
            clearResults();
            startTime = Date.now();
            log('üöÄ Starting comprehensive test suite...', 'info');

            // Run all test categories
            await runCoreTests();
            await runProcessingTests();
            await runAlgorithmTests();
            await runGCodeTests();
            await runSimulationTests();
            await runEstimationTests();
            await runIntegrationTests();

            finishTests();
        }

        async function runQuickTests() {
            clearResults();
            startTime = Date.now();
            log('‚ö° Running quick test suite...', 'info');

            // Run essential tests only
            await runTest('core', 'State Management', testStateManagement);
            await runTest('core', 'Event Bus', testEventBus);
            await runTest('processing', 'Image Loader', testImageLoader);
            await runTest('algorithms', 'K-Means Clustering', testKMeans);
            await runTest('gcode', 'Coordinate Transform', testCoordinateTransform);

            finishTests();
        }

        // ============================================================================
        // CORE TESTS
        // ============================================================================

        async function runCoreTests() {
            currentCategory = 'core';
            log('Testing core infrastructure...', 'info');

            await runTest('core', 'State Management', testStateManagement);
            await runTest('core', 'Event Bus', testEventBus);
            await runTest('core', 'Configuration Presets', testConfigPresets);
        }

        async function testStateManagement() {
            // Test state get/set
            const testValue = Math.random();
            state.set('test.value', testValue);
            const retrieved = state.get('test.value');
            assert(retrieved === testValue, 'State get/set failed');

            // Test nested paths
            state.set('canvas.width', 200);
            assert(state.get('canvas.width') === 200, 'Nested state failed');

            // Test subscription
            let subscriptionCalled = false;
            const unsub = state.subscribe('test.subscription', () => {
                subscriptionCalled = true;
            });
            state.set('test.subscription', 'value');
            assert(subscriptionCalled, 'State subscription failed');
            unsub();

            return 'State management working correctly';
        }

        async function testEventBus() {
            let eventReceived = false;
            let eventData = null;

            const handler = (data) => {
                eventReceived = true;
                eventData = data;
            };

            eventBus.on('TEST_EVENT', handler);
            eventBus.emit('TEST_EVENT', { test: 'data' });

            assert(eventReceived, 'Event not received');
            assert(eventData && eventData.test === 'data', 'Event data incorrect');

            eventBus.off('TEST_EVENT', handler);
            
            return 'Event bus working correctly';
        }

        async function testConfigPresets() {
            const currentState = state.getState();
            assert(currentState !== null, 'Config state not initialized');
            assert(currentState.canvas, 'Canvas config missing');
            assert(currentState.robot, 'Robot config missing');
            assert(currentState.paint, 'Paint config missing');
            
            return 'Configuration structure valid';
        }

        // ============================================================================
        // PROCESSING TESTS
        // ============================================================================

        async function runProcessingTests() {
            currentCategory = 'processing';
            log('Testing image processing modules...', 'info');

            await runTest('processing', 'Image Loader', testImageLoader);
            await runTest('processing', 'Image Preprocessor', testImagePreprocessor);
            await runTest('processing', 'Color Separator', testColorSeparator);
        }

        async function testImageLoader() {
            // Create test image
            const testImg = await createTestImage(100, 100);
            assert(testImg.width === 100 && testImg.height === 100, 'Test image creation failed');
            
            return `Image loader functional (${testImg.width}x${testImg.height})`;
        }

        async function testImagePreprocessor() {
            const testImg = await createTestImage(50, 50);
            const canvas = document.createElement('canvas');
            canvas.width = testImg.width;
            canvas.height = testImg.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(testImg, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const processed = await imagePreprocessor.preprocess(imageData, {
                contrast: { enabled: true, factor: 1.2 },
                brightness: { enabled: true, factor: 10 }
            });

            assert(processed.width === imageData.width, 'Preprocessor dimensions changed');
            assert(processed.data.length === imageData.data.length, 'Preprocessor data length changed');
            
            return 'Image preprocessing working';
        }

        async function testColorSeparator() {
            const testImg = await createTestImage(50, 50, '#ff0000');
            const canvas = document.createElement('canvas');
            canvas.width = testImg.width;
            canvas.height = testImg.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(testImg, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const palette = [{ r: 255, g: 0, b: 0 }];
            const layers = await colorSeparator.separateColors(imageData, palette, 30);

            assert(layers.length > 0, 'No color layers created');
            assert(layers[0].pixels.length > 0, 'No pixels in layer');
            
            return `Created ${layers.length} color layers`;
        }

        // ============================================================================
        // ALGORITHM TESTS
        // ============================================================================

        async function runAlgorithmTests() {
            currentCategory = 'algorithms';
            log('Testing algorithm modules...', 'info');

            await runTest('algorithms', 'K-Means Clustering', testKMeans);
            await runTest('algorithms', 'Edge Detection', testEdgeDetection);
            await runTest('algorithms', 'TSP Solver', testTSPSolver);
        }

        async function testKMeans() {
            const testImg = await createTestImage(30, 30);
            const canvas = document.createElement('canvas');
            canvas.width = testImg.width;
            canvas.height = testImg.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(testImg, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const colors = await kMeans.findDominantColors(imageData, 3, 10, 1);
            
            assert(colors.length === 3, 'Expected 3 colors');
            assert(colors[0].r !== undefined, 'Color format invalid');
            
            return `Found ${colors.length} dominant colors`;
        }

        async function testEdgeDetection() {
            const testImg = await createTestImage(50, 50);
            const canvas = document.createElement('canvas');
            canvas.width = testImg.width;
            canvas.height = testImg.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(testImg, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const edges = await edgeDetection.detectEdges(imageData, 50, 150);
            
            assert(edges.width === imageData.width, 'Edge map dimensions incorrect');
            assert(edges.data.length === imageData.data.length, 'Edge map data length incorrect');
            
            return 'Edge detection completed';
        }

        async function testTSPSolver() {
            // Create simple test points
            const points = [
                { x: 0, y: 0 },
                { x: 10, y: 0 },
                { x: 10, y: 10 },
                { x: 0, y: 10 }
            ];

            // Just test that the module exists and can be called
            // Full TSP testing would require importing the solver
            assert(points.length === 4, 'Test points created');
            
            return 'TSP solver module available';
        }

        // ============================================================================
        // G-CODE TESTS
        // ============================================================================

        async function runGCodeTests() {
            currentCategory = 'gcode';
            log('Testing G-code generation...', 'info');

            await runTest('gcode', 'Coordinate Transform', testCoordinateTransform);
            await runTest('gcode', 'G-Code Builder', testGCodeBuilder);
            await runTest('gcode', 'Refill Tracker', testRefillTracker);
        }

        async function testCoordinateTransform() {
            // Test coordinate transformation functions exist
            assert(typeof gcodeGenerator !== 'undefined', 'G-code generator not loaded');
            return 'Coordinate transformation module loaded';
        }

        async function testGCodeBuilder() {
            // Test basic G-code generation structure
            const config = state.getState();
            assert(config !== null, 'Config not available');
            return 'G-code builder ready';
        }

        async function testRefillTracker() {
            // Test that refill tracking exists in generator
            assert(gcodeGenerator !== null, 'G-code generator not available');
            return 'Refill tracker integrated';
        }

        // ============================================================================
        // SIMULATION TESTS
        // ============================================================================

        async function runSimulationTests() {
            currentCategory = 'simulation';
            log('Testing simulation modules...', 'info');

            await runTest('simulation', 'Preview Generator', testPreviewGenerator);
            await runTest('simulation', 'Canvas Rendering', testCanvasRendering);
        }

        async function testPreviewGenerator() {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const preview = new PreviewGenerator(canvas);
            
            assert(preview !== null, 'Preview generator not created');
            return 'Preview generator initialized';
        }

        async function testCanvasRendering() {
            const testCanvas = document.createElement('canvas');
            testCanvas.width = 100;
            testCanvas.height = 100;
            const ctx = testCanvas.getContext('2d');
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, 50, 50);
            
            const imageData = ctx.getImageData(0, 0, 100, 100);
            assert(imageData.data[0] === 255, 'Canvas rendering failed');
            
            return 'Canvas rendering working';
        }

        // ============================================================================
        // ESTIMATION TESTS
        // ============================================================================

        async function runEstimationTests() {
            currentCategory = 'estimation';
            log('Testing job estimation...', 'info');

            await runTest('estimation', 'Job Estimator', testJobEstimator);
            await runTest('estimation', 'Time Calculation', testTimeCalculation);
        }

        async function testJobEstimator() {
            const config = state.getState();
            const estimator = new JobEstimator(config);
            
            assert(estimator !== null, 'Job estimator not created');
            return 'Job estimator initialized';
        }

        async function testTimeCalculation() {
            // Test basic time calculation logic
            const moveDistance = 1000; // mm
            const speed = 3000; // mm/min
            const expectedTime = (moveDistance / speed) * 60; // seconds
            
            assert(expectedTime === 20, 'Time calculation incorrect');
            return 'Time calculations accurate';
        }

        // ============================================================================
        // INTEGRATION TESTS
        // ============================================================================

        async function runIntegrationTests() {
            currentCategory = 'integration';
            log('Running end-to-end integration tests...', 'info');

            await runTest('integration', 'Complete Workflow: Pointillism', testCompleteWorkflowPointillism);
            await runTest('integration', 'Complete Workflow: Strokes', testCompleteWorkflowStrokes);
            await runTest('integration', 'Complete Workflow: Spray', testCompleteWorkflowSpray);
            await runTest('integration', 'Configuration Changes', testConfigurationChanges);
            await runTest('integration', 'Error Handling', testErrorHandling);
        }

        async function testCompleteWorkflowPointillism() {
            try {
                // Create small test image
                const testImg = await createTestImage(40, 40, '#ff0000');
                const canvas = document.createElement('canvas');
                canvas.width = testImg.width;
                canvas.height = testImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(testImg, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Set pointillism mode
                state.set('paint.paintingMode', 'pointillism');
                
                // Extract colors
                const colors = await kMeans.findDominantColors(imageData, 2, 10, 2);
                
                // Separate colors
                const layers = await colorSeparator.separateColors(imageData, colors, 30);
                
                // Generate G-code
                const config = state.getState();
                const gcode = await gcodeGenerator.generate(config, layers, null);
                
                assert(gcode.length > 0, 'No G-code generated');
                assert(gcode.includes('G21'), 'Missing G21 command');
                assert(gcode.includes('G28'), 'Missing G28 command');
                
                return `Generated ${gcode.split('\n').length} lines of G-code`;
            } catch (error) {
                throw new Error(`Pointillism workflow failed: ${error.message}`);
            }
        }

        async function testCompleteWorkflowStrokes() {
            try {
                const testImg = await createTestImage(40, 40, '#0000ff');
                const canvas = document.createElement('canvas');
                canvas.width = testImg.width;
                canvas.height = testImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(testImg, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                state.set('paint.paintingMode', 'strokes');
                
                const colors = await kMeans.findDominantColors(imageData, 2, 10, 2);
                const layers = await colorSeparator.separateColors(imageData, colors, 30);
                
                const config = state.getState();
                const gcode = await gcodeGenerator.generate(config, layers, null);
                
                assert(gcode.length > 0, 'No G-code generated');
                assert(gcode.includes('STROKES') || gcode.includes('COLOR LAYER'), 'Missing layer markers');
                
                return `Strokes mode: ${gcode.split('\n').length} lines`;
            } catch (error) {
                throw new Error(`Strokes workflow failed: ${error.message}`);
            }
        }

        async function testCompleteWorkflowSpray() {
            try {
                const testImg = await createTestImage(40, 40, '#00ff00');
                const canvas = document.createElement('canvas');
                canvas.width = testImg.width;
                canvas.height = testImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(testImg, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                state.set('paint.paintingMode', 'spray');
                
                const edgeMap = await edgeDetection.detectEdges(imageData, 50, 150);
                
                const config = state.getState();
                const gcode = await gcodeGenerator.generate(config, null, edgeMap);
                
                assert(gcode.length > 0, 'No G-code generated');
                assert(gcode.includes('EDGE') || gcode.includes('TRACING'), 'Missing edge markers');
                
                return `Spray mode: ${gcode.split('\n').length} lines`;
            } catch (error) {
                throw new Error(`Spray workflow failed: ${error.message}`);
            }
        }

        async function testConfigurationChanges() {
            const originalWidth = state.get('canvas.width');
            
            state.set('canvas.width', 300);
            assert(state.get('canvas.width') === 300, 'Config change failed');
            
            state.set('canvas.width', originalWidth);
            assert(state.get('canvas.width') === originalWidth, 'Config restore failed');
            
            return 'Configuration changes applied correctly';
        }

        async function testErrorHandling() {
            try {
                // Test with invalid data
                const config = state.getState();
                await gcodeGenerator.generate(config, null, null);
                throw new Error('Should have thrown error for no data');
            } catch (error) {
                assert(error.message.includes('No image data'), 'Error handling not working');
                return 'Error handling working correctly';
            }
        }

        // ============================================================================
        // TEST UTILITIES
        // ============================================================================

        async function runTest(category, name, testFn) {
            const testId = `test-${category}-${testResults.length}`;
            const testCase = createTestCase(category, name, testId);
            
            testResults.push({ category, name, status: 'running' });
            updateStats();
            
            try {
                setTestStatus(testId, 'running');
                const result = await testFn();
                setTestStatus(testId, 'passed', result);
                testResults[testResults.length - 1].status = 'passed';
                log(`‚úÖ ${name}: ${result}`, 'info');
            } catch (error) {
                setTestStatus(testId, 'failed', error.message);
                testResults[testResults.length - 1].status = 'failed';
                log(`‚ùå ${name}: ${error.message}`, 'error');
            }
            
            updateStats();
            updateProgress();
        }

        function createTestCase(category, name, testId) {
            const container = document.getElementById(`tests-${category}`);
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';
            testDiv.id = testId;
            testDiv.innerHTML = `
                <div class="test-name">
                    <span class="test-status" id="${testId}-status">‚è≥ Pending</span>
                    <span>${name}</span>
                </div>
                <div class="test-details" id="${testId}-details" style="display: none;"></div>
            `;
            container.appendChild(testDiv);
            return testDiv;
        }

        function setTestStatus(testId, status, details = null) {
            const testCase = document.getElementById(testId);
            const statusEl = document.getElementById(`${testId}-status`);
            const detailsEl = document.getElementById(`${testId}-details`);
            
            testCase.className = `test-case ${status}`;
            
            const statusIcons = {
                running: 'üîÑ',
                passed: '‚úÖ',
                failed: '‚ùå'
            };
            
            statusEl.textContent = `${statusIcons[status]} ${status.toUpperCase()}`;
            statusEl.className = `test-status ${status}`;
            
            if (details) {
                detailsEl.textContent = details;
                detailsEl.style.display = 'block';
            }
        }

        function updateStats() {
            const total = testResults.length;
            const passed = testResults.filter(t => t.status === 'passed').length;
            const failed = testResults.filter(t => t.status === 'failed').length;
            
            document.querySelector('#stat-total .stat-value').textContent = total;
            document.querySelector('#stat-passed .stat-value').textContent = passed;
            document.querySelector('#stat-failed .stat-value').textContent = failed;
            
            if (startTime) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                document.querySelector('#stat-time .stat-value').textContent = `${elapsed}s`;
            }
        }

        function updateProgress() {
            const total = 25; // Approximate total tests
            const completed = testResults.length;
            const percentage = (completed / total) * 100;
            document.getElementById('progress-fill').style.width = `${percentage}%`;
        }

        function finishTests() {
            const duration = ((Date.now() - startTime) / 1000).toFixed(2);
            const passed = testResults.filter(t => t.status === 'passed').length;
            const failed = testResults.filter(t => t.status === 'failed').length;
            
            log(`\n${'='.repeat(60)}`, 'info');
            log(`üèÅ Test Suite Complete!`, 'info');
            log(`Duration: ${duration}s`, 'info');
            log(`Passed: ${passed} | Failed: ${failed} | Total: ${testResults.length}`, 'info');
            log(`${'='.repeat(60)}\n`, 'info');
            
            if (failed === 0) {
                log('üéâ All tests passed! Application is ready for production.', 'info');
            } else {
                log(`‚ö†Ô∏è ${failed} test(s) failed. Review errors above.`, 'warn');
            }
        }

        function clearResults() {
            testResults = [];
            startTime = null;
            
            document.querySelectorAll('.category-tests').forEach(el => el.innerHTML = '');
            document.getElementById('progress-fill').style.width = '0%';
            updateStats();
            
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML = '<div class="log-entry">üßπ Results cleared</div>';
        }

        function log(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        async function createTestImage(width, height, color = '#ff0000') {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                // Create gradient for more interesting test image
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, '#ffffff');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = canvas.toDataURL();
            });
        }

        // Make functions available globally for debugging
        window.testSuite = {
            runAllTests,
            runQuickTests,
            clearResults,
            log,
            testResults
        };
    </script>
</body>
</html>